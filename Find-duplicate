Find the any random duplicate number in the array.
找出数组中重复的数字。
=======
* method 1:从头到尾扫描排序，排序一个长度为n的数组需要n(nlogn)的时间。
_______

int findRepeatNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        for(int i=1;i<nums.size();i++){
            if(nums[i-1] == nums[i]) return nums[i];
        }
        return -1;
    }

class Solution:
    def findRepeatNumber(self, nums: List[int]) -> int:
        nums.sort()
        pre = nums[0]
        n = len(nums)
        for index in range(1, n):
            if pre == nums[index]:
                return pre
            pre = nums[index]
            
`一维数组在内存中占据连续的空间，可以根据下标定位对应的元素。`
* method 2:从头到尾扫描数组中每一个元素，没扫描到一个元素，用O(1)的时间判断哈希表中是否已经包含了该数字。
_______
c++
int findRepeatNumber(vector<int>& nums) {
        unordered_map<int,int> mp;
        for(int i=0;i<nums.size();i++){
            if(mp.find(nums[i]) != mp.end()) return nums[i];
            else mp[nums[i]] ++;
        }
        return -1;
    }
    
java   
class Solution {
    public int findRepeatNumber(int[] nums) {
        int[] arr = new int[nums.length];
        for(int i = 0; i < nums.length; i++){
            arr[nums[i]]++;
            if(arr[nums[i]] > 1) return nums[i];
        }
        return -1;
    }
}

python
class Solution:
    def findRepeatNumber(self, nums: List[int]) -> int:
        repeatDict = {}
        for num in nums:
            if num not in repeatDict:
                repeatDict[num] = 1
            else:
                return num
如果哈希表中已经存在该数字，就找到了一个重复的数字。time complexity：O(n) space complexity：O(n)

若数组中数字都在0～n-1的范围，若数组中无重复的数字，那么数组排序后数字i将出现在小标i的位置。`鸽巢原理`
* method 3:从头到尾扫描这个数组中每个数字，当扫描到下标为i的数字时，首先比较这个数字m是否等于i。
_______
是，则扫描下一个数字；不是则再拿它与第m个数字比较，若俩者相等，找到了一个重复的数字；若不相等，则把第m个数字与第i个数字交换；重复。。。
尽管如下代码有一个俩重循环，每个数字最多只要交换俩次即可找到属于它自己的位置，总time complexity是O(n)。
操作均在输入数组上进行，不需额外分配内存，space complexity：O(1)

bool duplicate(int numbers[], int length, int*duplication)
{
    if(numbers == nullptr||length <= 0)
    {
        return false;
    }
    
    for(int i == 0; i < length; ++i)
    {
        if(numbers[i]<0||numbers[i]>length-1)
            return false;
    }
    
    for(int i == 0; i < length; ++i)
    {
        while(numbers[i]!=i)
        {
            if(numbers[i] == numbers[numbers[i]])
            {
                *duplication = numbers[i];
                return true;
            }
            
            //swap numbers[i] and numbers[numbers[i]]
            int temp = numbers[i];
            numbers[i] = numbers[temp];
            numbers[temp] = temp;
        }
    }
    return false;
    
}

int findRepeatNumber(vector<int>& nums) {
        for(int i=0;i<nums.size();i++){
            while(nums[i]!=i){
                if(nums[nums[i]] == nums[i]) return nums[i];
                int tmp = nums[i];
                nums[i] = nums[tmp];
                nums[tmp] = tmp;
            }
        }
        return -1;
    }
    
class Solution:
    def findRepeatNumber(self, nums) -> int:
        n = len(nums)
        for i in range(n):
            while i != nums[i]:              
                if nums[i] == nums[nums[i]]:
                    return nums[i]
                temp = nums[i]
                nums[i], nums[temp] = nums[temp], nums[i]
                
不修改数组找到重复的数字
在一个长度为n+1的数组中，所有数字都在1～n的范围，所以数组中至少有一个数字是重复的。

* method 1: 创建一个长度为n+1的辅助数组，然后逐一把原数组的每个数字复制到辅助数组。
如果原数组中被复制的数字是m，则把它复制到辅助数组中下标为m的位置，space complexity：O(n)

* method 2:将1～n的数字从中间的数字m分为俩部分，前面一半为1～m，后面一半为m+1～n。
以时间换空间，该方法不能保证找到所有重复数字。
如果前面1～m的数字的数目超过m，那么这一半的区间一定包含重复的数字；否则另一半一定包含重复数字。
继续将包含重复数字的区间一分为二，直到找到一个重复的数字。此法与二分查找类似，多了一步统计区间里数字的数目。
总time complexity：O(nlogn)，space complexity：O(1)

int getDuplication(const int* numbers, int length)
{
    if(numbers == nullptr||length<=0)
        return -1;
    int start = 1;
    int ned = length -1;
    while(end >= start)
    {
        int muddle = ((end-start)>>1) + start;
        int count = countRange(numbers, length, start, middle); //对输入长度n的数组，函数countRange将被调用O(logn)次，每次需要O(n)的时间。
        if(end == start)
        {
            if(count > 1)
                return start;
            else
                break;
        }
        if(count > (middle-start+1))
            end = middle;
        else
            start = middle+1;
    }
    return -1;
}

int countRange(const int* numbers, inr length, int start, int end)
{
    if(numbers == nullptr)
        return 0;
    int count = 0;
    for(int i = 0; i<length;i++)
        if(numbers[i]>=start&&numbers[i]<=end)
            ++count;
    return count;
}


在一个长度为n+1的数组中，所有数字都在1～n的范围，所以数组中至少有一个数字是重复的。原数组
在一个长度为n+1的数组中，所有数字都在1～n的范围，所以数组中至少有一个数字是重复的。
